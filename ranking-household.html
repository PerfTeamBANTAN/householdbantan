<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rangking Household — Dashboard</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --black:#0b0b0b;
      --header-blue:#2f6fb8;
      --target-red:#d94b4b;
      --muted:#6b6b6b;
      --light-gray:#fafafa;
      --cell-border:#e6e6e6;
      --idx-w:260px;    /* fixed width INDEX column */
      --target-w:90px;  /* fixed width TARGET column */
      --agent-min-w:70px; /* minimum width per agent column */
      --agent-col-w:90px; /* will be overwritten by JS */
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: #fff;
      color: #222;
      padding-top: 70px;
    }

    .container-main { max-width:1280px; margin:0 auto; }

    .page-header { display:flex; align-items:center; gap:12px; margin-bottom: 12px; }
    .page-title { font-weight:700; font-size:20px; }

    .rank-wrapper {
      overflow:auto;
      background:#fff;
      padding:12px;
      border-radius:8px;
      box-shadow:0 2px 8px rgba(0,0,0,0.04);
    }

    /* Table: use fixed layout so widths are predictable, but we'll compute agent width */
    table.rank-table { border-collapse: collapse; width:100%; table-layout: fixed; min-width: 700px; }
    table.rank-table thead th, table.rank-table tbody td {
      border:1px solid var(--cell-border);
      vertical-align:middle;
      padding:8px 6px;
      font-size:13px;
    }

    /* Left columns - fixed */
    th.idx, td.idx { width: var(--idx-w); min-width: var(--idx-w); max-width: var(--idx-w); text-align:left; background:var(--light-gray); font-weight:700; padding:10px; }
    th.target, td.target { width: var(--target-w); min-width: var(--target-w); max-width: var(--target-w); text-align:center; font-weight:700; }

    /* Agent columns: use CSS variable for width */
    th.agent, td.agent { width: var(--agent-col-w); min-width: var(--agent-col-w); max-width: var(--agent-col-w); text-align:center; padding:8px; word-break:break-word; }

    /* Header styling: two rows */
    thead tr.header-top th {
      background: var(--black);
      color:#fff;
      font-weight:700;
      text-align:center;
      font-size:12px;
      padding:10px 6px;
    }
    thead tr.header-sub th {
      background: var(--header-blue);
      color:#fff;
      font-weight:600;
      text-align:center;
      font-size:11px;
      padding:6px 6px;
    }

    /* TARGET red cell style when appropriate */
    .cell-target { background: var(--target-red); color:#fff; }

    /* group header full-width */
    .group-header {
      background: var(--black);
      color:#fff;
      font-weight:700;
      padding:8px 12px;
      text-align:left;
    }

    /* numbers style */
    td.gp { font-weight:700; text-align:center; }
    td.gp.positive { color:#2c9a3d; }
    td.gp.negative { color:#d23b3b; }
    td.gp.neutral { color:var(--muted); }

    /* tidy */
    tbody td.idx { font-size:13px; }
    .small-note { font-size:12px; color:#666; }

    /* responsiveness: allow horizontal scroll when not enough room */
    @media (max-width: 1000px) {
      .container-main { padding: 0 10px; }
    }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top shadow-sm">
    <div class="container">
      <a class="navbar-brand" href="index.html">PERFORMANCE BAN-TAN</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navMain">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navMain">
        <ul class="navbar-nav me-auto">
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" data-bs-toggle="dropdown">Rangking</a>
            <ul class="dropdown-menu">
              <li><a class="dropdown-item active" href="ranking-household.html">Rangking Household</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <main class="container container-main">
    <div class="page-header">
      <img src="PERFORMANCE TEAM.png" alt="" style="height:42px;">
      <div>
        <div class="page-title">Ranking Household — RANKING HSA</div>
        <div class="small-note">Tabel akan otomatis menyesuaikan lebar kolom agent agar rapi</div>
      </div>
    </div>

    <div id="loading">Memuat data dari Google Sheets…</div>
    <div id="error" class="text-danger"></div>

    <div class="rank-wrapper d-none" id="rankWrap">
      <table class="rank-table" id="rankTable" aria-describedby="loading">
        <thead id="tableHead"></thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </main>

  <script>
    // CONFIG (sheets harus di-publish / anyone with link can view)
    const SPREADSHEET_ID = '1nJ5FQ4A9sd4FsxRXuAMr42eHalnd0N2Rm7dK_05Filg';
    const SHEET_NAME = 'RANKING HSA';
    const GVIZ_URL = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/gviz/tq?sheet=${encodeURIComponent(SHEET_NAME)}&tqx=out:json`;

    const idxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--idx-w')) || 260;
    const targetWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--target-w')) || 90;
    const agentMin = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--agent-min-w')) || 70;

    fetch(GVIZ_URL)
      .then(r => r.text())
      .then(text => {
        const jsonText = text.replace(/^[\s\S]*?setResponse\(|\);?\s*$/g, '');
        const data = JSON.parse(jsonText);
        buildAutoFitTable(data.table);
      })
      .catch(err => {
        document.getElementById('loading').style.display = 'none';
        const e = document.getElementById('error');
        e.style.display = 'block';
        e.textContent = 'Gagal memuat sheet. Pastikan sheet dipublikasikan (Anyone with link can view). Error: ' + err.message;
      });

    function buildAutoFitTable(table) {
      document.getElementById('loading').style.display = 'none';
      const cols = table.cols.map(c => c.label || c.id || '');
      const rows = table.rows || [];

      // detect start index (skip empty leading columns)
      let startIdx = 0;
      while (startIdx < cols.length && (!cols[startIdx] || cols[startIdx].trim() === '')) startIdx++;
      const idxCol = startIdx;
      const targetCol = startIdx + 1;
      const agentStart = startIdx + 2;
      const agentNames = cols.slice(agentStart).map(x => x || '');

      // determine available width inside wrapper
      const wrap = document.getElementById('rankWrap');
      // temporarily show wrapper (in case hidden) to measure
      wrap.classList.remove('d-none');
      // small timeout to ensure layout computed
      setTimeout(() => {
        const available = Math.max(600, wrap.clientWidth - idxWidth - targetWidth);
        const agentCount = Math.max(1, agentNames.length);
        let agentWidth = Math.floor(available / agentCount);
        if (agentWidth < agentMin) agentWidth = agentMin; // set minimum
        // set CSS variable
        document.documentElement.style.setProperty('--agent-col-w', agentWidth + 'px');

        // Now build header and body using that width
        renderTableContent(table, idxCol, targetCol, agentStart, agentNames);
      }, 10);
    }

    function renderTableContent(table, idxCol, targetCol, agentStart, agentNames) {
      const rows = table.rows || [];
      const thead = document.getElementById('tableHead');
      thead.innerHTML = '';

      // TOP header (names)
      const trTop = document.createElement('tr');
      trTop.className = 'header-top';
      const thIdx = document.createElement('th'); thIdx.className = 'idx'; thIdx.rowSpan = 2; thIdx.textContent = 'INDEX';
      const thTarget = document.createElement('th'); thTarget.className = 'target'; thTarget.rowSpan = 2; thTarget.textContent = 'TARGET';
      trTop.appendChild(thIdx); trTop.appendChild(thTarget);

      agentNames.forEach(name => {
        const th = document.createElement('th');
        th.className = 'agent';
        // allow name wrap across two lines, uppercase like sheet
        const t = document.createElement('div');
        t.style.fontWeight = '700';
        t.style.fontSize = '12px';
        t.style.whiteSpace = 'normal';
        t.style.lineHeight = '1.1';
        t.textContent = (name || '').toUpperCase();
        th.appendChild(t);
        trTop.appendChild(th);
      });
      thead.appendChild(trTop);

      // SUB header (Growth Point)
      const trSub = document.createElement('tr');
      trSub.className = 'header-sub';
      // create empty placeholders for idx & target because they have rowspan=2
      // we skip adding cells for them here (they already span)
      agentNames.forEach(_ => {
        const th = document.createElement('th');
        th.className = 'agent';
        th.textContent = 'Growth Point';
        trSub.appendChild(th);
      });
      thead.appendChild(trSub);

      // Build body
      const tbody = document.getElementById('tableBody');
      tbody.innerHTML = '';

      function isGroupHeader(row) {
        const c0 = row.c[idxCol];
        if (!c0 || !c0.v) return false;
        const v = ('' + c0.v).trim();
        if (!v) return false;
        const keywords = ['KPI', 'POINT RANKING', 'KPI B2C', 'KPI B2B', 'KPI 12 PI LATEN'];
        for (let k of keywords) if (v.toUpperCase().startsWith(k.toUpperCase())) return true;
        const otherPopulated = row.c.slice(idxCol+1).filter(x=>x && (x.v!==null && x.v!==undefined && x.v!== '')).length;
        if (otherPopulated <= 1 && v.length>0) return true;
        return false;
      }

      rows.forEach(row => {
        if (isGroupHeader(row)) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 2 + agentNames.length;
          td.className = 'group-header';
          td.textContent = row.c[idxCol] && row.c[idxCol].v ? row.c[idxCol].v : '';
          tr.appendChild(td);
          tbody.appendChild(tr);
          return;
        }

        const tr = document.createElement('tr');

        // INDEX
        const tdIndex = document.createElement('td');
        tdIndex.className = 'idx';
        const idxVal = (row.c[idxCol] && (row.c[idxCol].v !== null && row.c[idxCol].v !== undefined)) ? row.c[idxCol].v : (row.c[idxCol] && row.c[idxCol].f ? row.c[idxCol].f : '');
        tdIndex.textContent = idxVal || '';
        tr.appendChild(tdIndex);

        // TARGET
        const tdT = document.createElement('td');
        const tVal = (row.c[targetCol] && (row.c[targetCol].v !== null && row.c[targetCol].v !== undefined)) ? row.c[targetCol].v : (row.c[targetCol] && row.c[targetCol].f ? row.c[targetCol].f : '');
        if (String(tVal).toUpperCase().includes('TARGET') || String(tVal).trim() === '') {
          tdT.className = 'target cell-target';
        } else {
          tdT.className = 'target';
        }
        tdT.textContent = tVal || '';
        tr.appendChild(tdT);

        // agents
        for (let ci = agentStart; ci < agentStart + agentNames.length; ci++) {
          const cell = row.c[ci];
          let raw = '';
          if (cell) {
            if (cell.v !== null && cell.v !== undefined) raw = cell.v;
            else if (cell.f) raw = cell.f;
          }
          const td = document.createElement('td');
          td.className = 'agent';
          if (typeof raw === 'number') {
            td.className += ' gp ' + (raw > 0 ? 'positive' : (raw < 0 ? 'negative' : 'neutral'));
            td.textContent = raw;
          } else {
            const m = ((''+raw).match(/-?\d+/) || [null])[0];
            if (m !== null && m !== undefined) {
              const num = parseInt(m,10);
              td.className += ' gp ' + (num > 0 ? 'positive' : (num < 0 ? 'negative' : 'neutral'));
              td.textContent = (''+raw).trim();
            } else {
              td.textContent = raw || '';
              td.style.textAlign = 'center';
            }
          }
          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      });

      // done
      document.getElementById('rankWrap').classList.remove('d-none');
    }

    // Recompute sizes on window resize for responsiveness
    window.addEventListener('resize', () => {
      // refetch and rebuild to recompute widths could be heavy; instead just recompute CSS var
      const wrap = document.getElementById('rankWrap');
      if (!wrap || wrap.classList.contains('d-none')) return;
      const agentCount = document.querySelectorAll('#tableHead th.agent').length || 1;
      const available = Math.max(600, wrap.clientWidth - idxWidth - targetWidth);
      let agentWidth = Math.floor(available / agentCount);
      if (agentWidth < agentMin) agentWidth = agentMin;
      document.documentElement.style.setProperty('--agent-col-w', agentWidth + 'px');
    });

  </script>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
